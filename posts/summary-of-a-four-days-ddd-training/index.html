<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Summary of a four days DDD training - Thomas Ferro</title>
    <link rel="stylesheet" href="/assets/styles/font.css" type="text/css">
    <link rel="stylesheet" href="/assets/styles/main.css" type="text/css">
    <link rel="stylesheet" href="/assets/styles/title.css" type="text/css">
    <link rel="stylesheet" href="/assets/styles/list.css" type="text/css">
    <link rel="stylesheet" href="/assets/styles/blockquote.css" type="text/css">
    <link rel="stylesheet" href="/assets/styles/figure.css" type="text/css">
</head>
<body>
    <header>
        <a href="/">Thomas Ferro</a> - Web development engineer at <a href="https://www.sfeir.com/fr" target="_blank" rel="noopener noreferrer">Sfeir</a>
        <a href="https://dev.to/thomasferro" target="_blank" rel="noopener noreferrer"><img class="icon" src="/assets/images/dev-logo.svg" alt="DEV Community"></a>
        <a href="https://www.linkedin.com/in/thomas-ferro/" target="_blank" rel="noopener noreferrer"><img class="icon" src="/assets/images/linkedin-logo.png" alt="LinkedIn"></a>
        <a href="https://twitter.com/Thomas_Ferro_md" target="_blank" rel="noopener noreferrer"><img class="icon" src="/assets/images/twitter-logo.svg" alt="Twitter"></a>
    </header>
    <main><h1>Summary of a four days DDD training</h1>

<blockquote>
<p>Make your domains shine!</p>
</blockquote>

<p>I think that one could say I was already convinced by the benefits of the <em>Domain Driven Design</em>.</p>

<p>I learned the hard way that driving your software engineering by the technical end can lead to pretty catastrophic situations.</p>

<p>Technical debt, hard coupling with any data provider, having to translate every domain feature request to fit in the already infected code base&hellip; I found myself in this situation not long ago and it was really hard for me to find the root cause.</p>

<p>This is when I found out about DDD. It immediately connects to me as it was exactly the thing that I was not able to name! All of those smells could be avoided by working with the domain to create a software that really reflects it.</p>

<p>I started diving into the subject by reading <em>Eric Evans</em>&rsquo; <a href="https://www.oreilly.com/library/view/domain-driven-design-tackling/0321125215/"><strong>Blue Book</strong></a> and <em>Vaughn Vernon</em>&rsquo;s <a href="https://www.oreilly.com/library/view/domain-driven-design-distilled/9780134434964/"><strong>Green Book</strong></a> and we started implementing a few of the principles in my job, with the help of a coworker that already did in a previous mission.</p>

<p>I followed a four days (french) training given by <a href="https://twitter.com/hackyrjob"><em>HackYourJob</em></a>&rsquo;s <strong><a href="https://twitter.com/florentpellet">Florent Pellet</a></strong> on <em>DDD</em> and its implementation. It was an excellent experience as he was able to validate what I already learned while teaching me a whole lot of new concepts.</p>

<p>Here are my organized thoughts and notes about those great four days.</p>

<blockquote>
<p>Disclaimer: I wrote this article mainly to have a clean trace of this training. I would be glad if you find it interesting and if you use it as a quick reference, but I highly recommend that you dig deep into each subject.</p>
</blockquote>

<h2>My own expectations</h2>

<p>My main expectations for the whole training was the following:</p>

<ul>
<li>Validate what I previously learned;</li>
<li>Learn how to introduce the subject and onboard a tech-oriented team;</li>
<li>Hear some real world stories about the usage of <em>DDD</em>;</li>
<li>Have a clear definition of two <em>DDD</em> terms that I often mixed up: <em>Strategic</em> and <em>Tactical</em> patterns;</li>
<li>Learn more about <em>DDD-lite</em>, is it a fraud?</li>
</ul>

<h2>What is <em>DDD</em>?</h2>

<p>We started the training with some theoretical definitions.</p>

<blockquote>
<p>Note: Every definition will be stated as blockquotes. They are rewording of concept that I learned about in the training and do not engage anyone but myself.</p>
</blockquote>

<p>Obviously, it was a good idea to start with the explanation of <em>what is DDD</em>:</p>

<blockquote>
<p><em>DDD (Domain Driven Design)</em>: A set of tools aiming to manage <strong>software complexity</strong>.</p>
</blockquote>

<p>But what is <em>software complexity</em>? <em>Ben Moseley</em> and <em>Peter Marks</em> started their essay <strong>Out of the tar pit</strong> by stating that <em>&ldquo;Complexity is the single major difficulty in the successful development of large-scale software systems&rdquo;</em>. It can be divided into three types:</p>

<blockquote>
<p><em>Essential complexity</em>: The complexity that cannot be reduced, that is required to answer the need.</p>

<p><em>Mandatory accidental complexity</em>: The one we cannot do without (the network, the programming language, etc).</p>

<p><em>Optional accidental complexity</em>: The complexity caused by the use of an inadequate framework, by the use of a different language between the domain concerns and the development one, etc.</p>
</blockquote>

<p>The latest complexity type is the one that we are trying to reduce, while trying to manage the three of them better with <em>DDD</em>.</p>

<h2>It&rsquo;s all about <strong>context</strong></h2>

<p>Writing a piece of software can be reduced as finding the right abstraction to answer a need. This abstraction is deeply linked to the context of the need.</p>

<p>We are trying to answer a <strong>specific need</strong>, as opposed to a generic one.</p>

<p>Take this common example of a map. If you try to help a friend reaching his destination using the subway, you are not going to give him the entire map of the city. You will certainly give him the subway map, the <em>abstraction of the city in the context of the subway lines</em>.</p>

<blockquote>
<p><em>Bounded context</em>: Set of elements (classes, services, etc) containing only what is needed in a specific context. You should not be afraid to duplicate code between contexts for them to be the clearest possible.</p>
</blockquote>

<h2>The tools you <em>need</em> to understand your <em>needs</em></h2>

<p>Here are few of the tools we should use to truly understand our needs when building software:</p>

<ul>
<li>User meetings;</li>
<li>Domain experts interviews;</li>
<li>Event Storming (more on that later);</li>
<li>US Mapping (more on that online);</li>
<li>Impact Mapping: The goal of this workshop is to identify a goal, define actors, the impacts of each of the actors and the deliverables linked to these impacts.</li>
</ul>

<p>The point here is to <em>speak to the actors</em>, and not to base our choices on assumptions and transcriptions.</p>

<p>Those tools and other communication medium can help us create an <em>Ubiquitous Language</em>.</p>

<blockquote>
<p><em>Ubiquitous Language</em>: Common language spoken by every member of the team. Here, <strong>two identical words should have the same domain meaning</strong> and <strong>two different ones should not designate the same concept</strong>.</p>
</blockquote>

<p>The <em>Ubiquitous Language</em> helps us align the source code with the domain. A domain expert should be able to understand the source code (the domain one, obviously).</p>

<h2>Focus on Event Storming</h2>

<p>This type of workshop was not discussed on the <a href="https://www.oreilly.com/library/view/domain-driven-design-tackling/0321125215/"><strong>Blue Book</strong></a>, but it is still a quite relevant tool.</p>

<p>You could use it as a way to grasp the big picture of your project, or to try to find insight about a specific part of your domain. It is a medium of communication for every team members, where we start from the objectives and take a step back.</p>

<p>There are many ways to conduct the workshop, but here is how we did it at the training. The example is for a betting application, with the team trying to do a Big Picture Event Storming.</p>

<p>The <em>Product Owner</em> tells the story of the product, based on his vision of it.</p>

<p>Every time someone find a domain event related to the story told, he writes it down on a sticky-note of any color (usually an orange one) and put it on a timeline.</p>

<blockquote>
<p>Example: Goal scored</p>
</blockquote>

<p>Once the <em>Product Owner</em> finished his story, the team tries to associate a command (blue sticky-note) and an actor (yellow sticky-note) on every domain event. This process reverse the narration.</p>

<blockquote>
<p>Example: Score a goal, by a player.</p>
</blockquote>

<p>The next step is to regroup the events/commands/actors in aggregates, the timeline can be ignored for the end of the workshop.</p>

<blockquote>
<p>Example: A &ldquo;match&rdquo; aggregate arise with the &ldquo;Goal scored&rdquo; event and the associated command and actor, plus other events related to the players.</p>
</blockquote>

<p>The final step is to regroup aggregates in contexts.</p>

<blockquote>
<p>Note: We did use this tool in my current mission, but with a more anarchist twist: we started by adding every domain events that crossed our mind, then we filtered them. I personally find this introduction to be less productive since you spend most of the workshop sorting sticky-notes.</p>
</blockquote>

<p>When doing this workshop, you should be careful to always use the <em>Ubiquitous Language</em>, and you can mark the uncertainties with red sticky-notes.</p>

<p>This is a really diminishing description, I urge you to read <a href="https://www.eventstorming.com/"><em>Alberto Bradolini</em>&rsquo;s <strong>Event Storming</strong> materials</a> for more information.</p>

<h2>Organize your inter-contexts communications</h2>

<p>When using <em>DDD</em> at the enterprise scale, you need to set up inter-teams and inter-contexts strategies.</p>

<p>This is where the <em>Strategic Patterns</em> play their part.</p>

<blockquote>
<p><em>Strategic Patterns</em>: Communication patterns used to organize the exchanges between contexts.</p>

<p><em>Upstream</em>: The upstream can be seen as the owner of the data, of the features.</p>

<p><em>Downstream</em>: The downstream can be seen as the client, he will usually be influenced by the upstream.</p>
</blockquote>

<p>Here is a quick description of each of the patterns introduced during the training:</p>

<ul>
<li><em>Big Ball of Mud</em>: Basically any situation where the communications go in every direction. Spoiler alert: it is bad;</li>
<li><em>Partnership</em>: When two contexts work together in a situation when if one fails, the other goes down with him;</li>
<li><em>Conformist</em>: One context comply to the other one&rsquo;s vision. The downstream does not have his word to say in the choices made by the upstream;</li>
<li><em>Customer/Supplier</em>: Like the <em>Conformist</em> approach, the downstream consumes the upstream&rsquo;s features but the downstream can makes requests for changes or new features;</li>
<li><em>Separate ways</em>: In the not-so-rare situation when you have two different solutions to the same problem, two contexts can decide to have zero communication and find their own way;</li>
<li><em>Published language</em>: Everyone follows a contract, a standard;</li>
<li><em>Open Host Service</em>: The upstream&rsquo;s provide an <em>API</em> that is consumed by everyone who needs it;</li>
<li><em>Shared Kernel</em>: This is the one that I personally dislike the most. It is basically sharing some code between multiple contexts, via a library for instance. I dislike it because I found it odd to have to share some code, I cannot think of any case where this is not a smell of a bad responsibilities split. Feel free to prove me wrong!</li>
</ul>

<p>Now, if you want to protect your context from the outer world&rsquo;s noises, you could put an <em>Anticorruption Layer</em> (or <em>ACL</em>) in your inputs and outputs. You can do so just by making the communications from and to your <em>domain</em> going through an <em>interface</em>. Your infrastructure layer will have the responsibility to implements this interface and by doing so translate the messages for the world to understand.</p>

<p>To visualize the whole <em>Strategic Patterns</em> and contexts in play, you can draw a <em>Context Map</em>. This is a map of all of the contexts, their interactions and the type of those. Take <a href="http://verraes.net/2014/01/bandwidth-and-context-mapping/"><strong>Mathias Verraes</strong>&rsquo;s example</a> for a more in-depth look.</p>

<p>We have seen the patterns used to communicate between the contexts, now we will see the patterns used in the actual code.</p>

<h2>Organize your code</h2>

<blockquote>
<p><em>Tactical patterns</em>: Engineering patterns used to organize the code-base in order to reflect the domain.</p>
</blockquote>

<p>Here is a quick description of the building blocks described in <em>Eric Evans</em>&rsquo; <a href="https://www.oreilly.com/library/view/domain-driven-design-tackling/0321125215/"><strong>Blue Book</strong></a>, please go back to this book if you want more information.</p>

<ul>
<li><em>Value Object</em>: An object that has no identity, no lifetime and who is compared based on his values;

<ul>
<li>Example: the red color can be represented as an object with the <em>hexadecimal</em> value set to <em>&rdquo;#FF0000&rdquo;</em>;</li>
</ul></li>
<li><em>Aggregate</em>: Special kind of <em>Entity</em>, has an identity and a lifetime. Can be composed of <em>Value Objects</em> and <em>Entities</em>, but not of other <em>aggregates</em>;

<ul>
<li>Responsible for the domain logic for a single <em>aggregate</em>, every action on the aggregate or the elements inside it must go through him;</li>
<li>Cannot directly communicate with other <em>aggregates</em>, those communications must go through a <em>service</em>;</li>
<li>Example: A person can be represented as an object with attributes and identified with his social security number. Actions on this person&rsquo;s tooth must go through the <em>aggregate</em> representing him, not directly on the tooth;</li>
</ul></li>
<li><em>Entity</em>: An object with an identity unique inside the aggregate;

<ul>
<li>Example: The front-left wheel in a car;</li>
</ul></li>
<li><em>Service</em>: Has no lifetime nor data. Used to synchronize aggregates;</li>
<li><em>Domain Event</em>: Used to communicate with the world. Can be seen as a <em>Value Object</em> representing a decision made.</li>
</ul>

<p>Additionally, two patterns are usually used to manipulate <em>aggregates</em>:</p>

<ul>
<li><em>Repository</em>: Used to manipulate collections of <em>aggregates</em>, to persist them for example;</li>
<li><em>Factory</em>: Used to build non-trivial <em>aggregates</em>. To be used when the <em>aggregate</em>&rsquo;s constructor is not enough and the creation logic is too complicated.</li>
</ul>

<h2>DDD and Software Architecture</h2>

<p><strong>Loose coupling / high cohesion</strong> is something you want to achieve when building an application with the <em>DDD</em> tools.</p>

<p>I will list some architectural patterns that you can use to do so, but please remember to be <strong>practical</strong>. You can combine all of those patterns, but it will create complexity. You should always ask yourself if it is worth the investment before implementing one of those.</p>

<h3>Hexagonal architecture / Ports and Adapters</h3>

<blockquote>
<p><em>Hexagonal architecture</em>: Also known as <em>Ports and Adapters</em>. Pattern coined by <a href="https://twitter.com/totheralistair">Alistair Cockburn</a> aiming to isolate the domain concerns from the infrastructure ones.</p>
</blockquote>

<p><img src="https://github.com/ThomasFerro/readmes/blob/master/posts/10-summary-of-a-four-days-ddd-training/hexagonal-architecture.png" alt="Hexagonal architecture / Ports and Adapters" /></p>

<blockquote>
<p>Credits to <em>Maxime COLIN</em> for the schema on the <em>Elao</em>&rsquo;s blog.</p>
</blockquote>

<p>This pattern is quite simple to put in place. It is mainly about interfacing the interaction with the outer world.</p>

<p>You have two kind of ports:</p>

<ul>
<li>&ldquo;In&rdquo;: the entry points to the domain;</li>
<li>&ldquo;Out&rdquo;: the exit points.</li>
</ul>

<p>For instance, you will have an entry port as an interface with the actions available in your domain. This interface could be implemented by a <em>REST API</em>, a <em>Message Queue</em> or event a <em>Command Line Interface</em>, the domain concern will not change.</p>

<p>The same goes for the exit points, no matter where you are retrieving or persisting your data, the domain is not impacted.</p>

<p>A more advanced architectural pattern based on the same principles is <em>Robert C. Martin</em>&rsquo;s <a href="https://www.goodreads.com/book/show/18043011-clean-architecture"><strong>Clean Architecture</strong></a>. I wont go into much details here since we did not see it in the training, but I do think that it is a great way to respect the <em>Clean Code</em> principles.</p>

<p><img src="https://github.com/ThomasFerro/readmes/blob/master/posts/10-summary-of-a-four-days-ddd-training/clean-architecture.jpeg" alt="Uncle Bob&rsquo;s Clean Architecture" /></p>

<h3>Event Sourcing</h3>

<blockquote>
<p><em>Event Sourcing</em>: Architectural pattern focusing on the path that led us there instead of where we are right now.</p>
</blockquote>

<p><img src="https://github.com/ThomasFerro/readmes/blob/master/posts/10-summary-of-a-four-days-ddd-training/event-sourcing.png" alt="Event Sourcing schema" /></p>

<p>It all start with an <em>aggregate</em> receiving a <em>command</em>. Based on this <em>command</em>, the <em>aggregate</em> will make decisions in the - wait for it - <em>decision methods</em>.</p>

<p>Those <em>decision methods</em> will then return events.</p>

<p>Those events will be applied to the <em>aggregate</em> in order to modify his current state. This process is done in <em>application methods</em>.</p>

<p>The events are not only applied, they can also be sent outside the <em>aggregate</em>, stored and published for side-effects. For instance, an event can trigger a mail notification when published.</p>

<p>You might need a concrete example, here is one in the context of our Betting app:</p>

<ul>
<li>A goal is scored, represented as a <em>command</em> in the <strong>Match</strong> <em>aggregate</em>;</li>
<li>The <em>decision method</em> handling the command, based on the data inside the command, decide to send the following event: <strong>ScoreGoaled</strong> with the player who scored, the time, etc;</li>
<li>This event is applied to the current match, updating his state;</li>
<li>It is also stored and published, triggering the notification system for the users who bet on the match.</li>
</ul>

<p>This example does not go into details about how to loop in the <em>decide/events/apply</em> iteration, but know that there are use cases when you will need to.</p>

<p>We talked about storing events, but what about persistency ? Do we still be using a relational database ?</p>

<blockquote>
<p><em>Event Store</em>: Persistency mechanism where you are not storing the current state of a data, but all the events that led to this state.</p>
</blockquote>

<p>Take for example an <em>aggregate</em> representing a car. You can choose to store the current state of the car, of his wheels, engine, etc in a relational database, or you can store <strong>every events that occurred on the car</strong>. May they be a <em>gas refuel</em>, <em>oil change</em>, <em>wheel change</em>, etc.</p>

<p>You can then rebuild the <em>aggregate</em> by replaying all of the events since they are idempotents.</p>

<p>This approach works especially well with <em>DDD</em> since you can use the <em>domain events</em> already discovered in workshop such as Event Storming. Events applied on <em>aggregates</em> should match 1:1 those <em>domain events</em>.</p>

<p>You can go even further by combining <em>Event Sourcing</em> with another mechanism, <em>CQRS</em> who come in handy when dealing with performance issues.</p>

<h3>CQRS</h3>

<blockquote>
<p><em>Command Query Responsibility Segregation</em> (or <em>CQRS</em>): Split your application in two components: the <em>Command</em> to update the data and the <em>Query</em> to retrieve it.</p>
</blockquote>

<p><img src="https://github.com/ThomasFerro/readmes/blob/master/posts/10-summary-of-a-four-days-ddd-training/cqrs.png" alt="CQRS schema" /></p>

<p>This pattern is especially useful when the update requests and the read ones happen at a very different rate.</p>

<p>For instance, take a booking application. You can have a huge traffic, meaning a lot of query request, while only a small portion of those visitors end up booking an actual trip. In this situation, having a lightweight application managing the <em>commands</em> can be enough, and you can focus your efforts on the <em>query</em> application that will need to manage the load.</p>

<p>To oversimplify the process, you can put it this way :</p>

<ol>
<li>A <em>command</em> is played on an <em>aggregate</em>;</li>
<li>This command generate <em>events</em>, modifying the <em>aggregate</em>;</li>
<li>Those events can be stored, but they especially are catched by the projections impacted;</li>
<li>Those projections update themselves, updating the <em>queries</em>.</li>
</ol>

<p>The clients only consume projections, which is faster than having to rebuild the <em>aggregates</em> every time.</p>

<h2>Back to the training</h2>

<p>The training did a great job introducing the tools and concepts while making us practice with a lot of examples.</p>

<p>I tried to put in this article every major themes, consider it a quick go-to when trying to explain what is <em>DDD</em>.</p>

<p>Events and projections persistency, transactions, events lifetime and more details about the implementation of a <em>CQRS / ES</em> (<em>Command Query Responsibility Segregation</em> / <em>Event Sourcing</em>) architecture are not discussed here. Those advanced concepts are yours to discover and practice!</p>

<p>I want to thank <a href="https://symbol-it.fr/"><strong>Symbol-it</strong></a>, the company I work for, for the logistic and for listening to my personal training wishes.</p>

<p>And of course, a huge thank you to <em>Florent Pellet</em> for sharing his knowledge and spending those enlightening four days with us!</p>
</main>
    <footer>Â© Thomas Ferro - 2021</footer>
</body>
</html>