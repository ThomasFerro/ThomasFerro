<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TDD in action : Debouncer in Go - Thomas Ferro</title>
    <link rel="stylesheet" href="/assets/styles/font.css" type="text/css">
    <link rel="stylesheet" href="/assets/styles/main.css" type="text/css">
    <link rel="stylesheet" href="/assets/styles/title.css" type="text/css">
    <link rel="stylesheet" href="/assets/styles/list.css" type="text/css">
    <link rel="stylesheet" href="/assets/styles/blockquote.css" type="text/css">
    <link rel="stylesheet" href="/assets/styles/figure.css" type="text/css">
</head>
<body>
    <header>
        <a href="/">Thomas Ferro</a> - Web development engineer at <a href="https://www.sfeir.com/fr" target="_blank" rel="noopener noreferrer">Sfeir</a>
        <a href="https://dev.to/thomasferro" target="_blank" rel="noopener noreferrer"><img class="icon" src="/assets/images/dev-logo.svg" alt="DEV Community"></a>
        <a href="https://www.linkedin.com/in/thomas-ferro/" target="_blank" rel="noopener noreferrer"><img class="icon" src="/assets/images/linkedin-logo.png" alt="LinkedIn"></a>
        <a href="https://twitter.com/Thomas_Ferro_md" target="_blank" rel="noopener noreferrer"><img class="icon" src="/assets/images/twitter-logo.svg" alt="Twitter"></a>
    </header>
    <main><h1>TDD in action : Debouncer in Go</h1>

<blockquote>
<p>Applying TDD principles to the making of a helper in Go</p>
</blockquote>

<h2>Introduction</h2>

<p>I may be new to the Golang world, but here is something I am already familiar with: <strong>Building things in Go feels great !</strong></p>

<p>What feels event better is to build those things with the absolute certainty that it works the way it was meant to be.</p>

<p>I am leaving the preaching and teaching parts to <em>Kent Beck</em> and consort. I can, however, tell you that the <em>Test Driven Development</em> (or <em>TDD</em>) principles are perfect to give you that certainty.</p>

<p>Following the TDD principles in Go does not require any particular setup. No dependency or IDE plugin to install and configure. You just grab your favorite text editor, a terminal plus a notebook and a pen if it suits you better !</p>

<h2>Writing tests in Go</h2>

<p>Follow those few steps to start writing tests in Go :</p>

<ol>
<li>In the same folder as the file under test, write a new file following this pattern : <code>yourFile_test.go</code>;</li>
<li>In this test file, create a new function with the specific name and signature : <code>func TestXxx(*testing.T)</code></li>
<li>Manage your test the way you need to, using the API provided by the <code>testing.T</code> object;</li>
<li>Run the <code>go test</code> command</li>
<li>Analyse the result to see if the tests succeed</li>
</ol>

<p>The standard API does not provide any fancy testing feature, but all we need for writing basic tests is there <em>out of the box</em>.</p>

<h2>The context</h2>

<p>I am currently building a development environment in Go. This dev env will be capable of running all of the tests and building and executing the program under development.</p>

<p>To do so, I need a files watcher, notifying the dev env each time a file is created, modified or deleted.</p>

<p>The main issue I ran into is that the event triggered by the files watcher may be emitted too many times at once.</p>

<p>Nothing too fancy here, all I need is a rather common feature called <strong>debouncing</strong>.</p>

<p>I am sure that a lot of libraries may tackle this issue in Go. However, I found it to be a great challenge for the beginner that I am with this language.</p>

<p>So, let&rsquo;s write this in tiny little tested steps, making <em>Kent Beck</em> and the Clean Code community pride in the process !</p>

<h2>How does a debouncer look like ?</h2>

<p>I am willing to create a debouncer in its most common API.</p>

<p>This means providing a debouncer as a helper function which takes a function as his first parameter and a timer as the second one. The timer represents how long should the program wait after the last call before executing the method.</p>

<p>The user will wrap his treatment in a debounced method, and call the wrapped function :</p>

<pre><code class="language-go">// Wrapping the debounced treatment
myDebouncedFunction := debounce(func() {
    // The treatment...
}, 500)

// Example 1 - Simple call
myDebouncedFunction() // The method will be called in 500ms

// Example 2 - Multiple calls
myDebouncedFunction() // Method's execution cancelled by the next call to myDebouncedFunction
time.Sleep(100 * time.Millisecond)
myDebouncedFunction() // Method's execution cancelled by the next call to myDebouncedFunction
time.Sleep(100 * time.Millisecond)
myDebouncedFunction() // The method will only be called once in 500ms
</code></pre>

<h2>TDD</h2>

<p>As I said earlier, I am not going into much details about what is TDD and why it is great. If you have not already, please read &ldquo;Test Driven Development: By Example&rdquo; by Kent Beck and try to apply the principles described there if they suits you.</p>

<p>Here is my take on the subject, if you are not familiar with it :</p>

<p>In order to build a product that really fits the needs that it addresses, the <em>TDD</em> proposes to first write the tests that the program should be able to pass.</p>

<p>To do so, we need to reduce the feedback loop to the bare minimum by following those three steps :</p>

<ol>
<li>Write a test with a dreamed API, the way you think the program should work. This test should not go green yet;</li>
<li>Write the simpliest, dumbest implementation to make the test succeed. This way, you will know if the following modifications break the promise;</li>
<li>Refactor the code (and the test if needed) in order to really solve the problem raised by the test. <strong>You have restrain yourself to the scope of the test</strong>, do not refactor or optimise the code to solve future features just now.</li>
</ol>

<p>Then you repeat the process with the next test, until all of the use cases are tackled and all of the features implemented</p>

<p>Let&rsquo;s jump into it, one test at the time !</p>

<h2>Calling the provided method after the timer has ended</h2>

<p>The first thing I want to check is very basic, <em>is the provided method called ?</em></p>

<p>Using only the standard API, and following the guideline introduced in the &ldquo;<em>How does a debouncer look like ?</em>&rdquo; chapter, one could implement this test like this :</p>

<pre><code class="language-go">func TestShouldCallTheFunctionAfterTheProvidedTime(t *testing.T) {
    called := false
    debouncedMethod := Debounce(func() {
        called = true
    }, 1)

    debouncedMethod()

    time.Sleep(10 * time.Millisecond)

    if called == false {
        t.Error(&quot;The method was not called&quot;)
    }
}
</code></pre>

<p>The test wraps a method in a very short debouncer, then it waits for the debounce to happen. The last step is to check if the method was called, throwing an error if it does.</p>

<p>Now that we have a test in place, we can try to make it pass with the most obvious implementation.</p>

<p>We can just return a function that calls the provided method, without taking care of the timer :</p>

<pre><code class="language-go">func Debounce(function func(), executeAfter int) func() {
    return func() {
        function()
    }
}
</code></pre>

<p>The test is green, we could now focus on refactoring. However, we will wait for the next test to be written before doing any refactoring, you will understand why shortly.</p>

<h2>Calling the method only after the timer</h2>

<p>Next, we need to check that the method was only called after the provided duration.</p>

<p>The test will look very similar to the last one, but we will check the opposite assertion and wait less than the timer :</p>

<pre><code class="language-go">func TestShouldNotCallTheFunctionBeforeTheProvidedTime(t *testing.T) {
    called := false
    debouncedMethod := Debounce(func() {
        called = true
    }, 10)

    debouncedMethod()

    time.Sleep(1 * time.Millisecond)

    if called == true {
        t.Error(&quot;The method was called too early&quot;)
    }
}
</code></pre>

<p>If you run it immediately, this test will not pass. The simplest way of changing that is to wait for the provided time before executing the function :</p>

<pre><code class="language-go">func Debounce(function func(), executeAfter int) func() {
    return func() {
        go (func() {
            time.Sleep(time.Duration(executeAfter) * time.Millisecond)
            function()
        })()
    }
}
</code></pre>

<p>We need to wrap the method in a goroutine in order for the program to continue its execution, and not wait for the <code>time.Sleep</code> method to finish. Remember, the point here is to make the tests pass, and both did !</p>

<p>Now, we clearly have a design issue, even a standard API misusage. Time for a little refactoring !</p>

<p>We can change the behavior, while launching the tests at every step to assure everything still runs smoothly.</p>

<p>We have used the <code>time.Sleep</code> where the <a href="https://golang.org/pkg/time/#NewTimer"><code>NewTimer</code> method of the same package</a> seems more appropriate.</p>

<p>First, we need to create a new timer based on the parameters and immediatly stop it :</p>

<pre><code class="language-go">func Debounce(function func(), executeAfter int) func() {
    duration := time.Duration(executeAfter) * time.Millisecond
    t := time.NewTimer(duration)
    t.Stop()
    // [...]
</code></pre>

<p>A goroutine can be started next with an infinite loop, watching for the timer to be finished and calling the debounced method :</p>

<pre><code class="language-go">    // [...]
    go (func() {
        for {
            select {
            case &lt;-t.C:
                log.Println(&quot;Executing the debounced method&quot;)
                go function()
            }
        }
    })()
    // [...]
</code></pre>

<p>Then we can return a function that restarts the timer :</p>

<pre><code class="language-go">    return func() {
        log.Println(&quot;Reset the debouncer timer&quot;)
        t.Reset(duration)
    }
</code></pre>

<p>This implementation lets the tests green, we can now move to the next tests with a little surprise&hellip;</p>

<h2>The last tests</h2>

<p>Finally, the goal of the debouncer is to ensure that the method is only executed once if called multiple times.</p>

<p>We can check that by creating a new test that keeps track of the execution count. If this number is not one, the test fails :</p>

<pre><code class="language-go">func TestShouldCallTheFunctionOnlyOnceAfterTheProvidedTime(t *testing.T) {
    executionCount := 0
    debouncedMethod := Debounce(func() {
        executionCount++
    }, 1)

    debouncedMethod()
    debouncedMethod()
    debouncedMethod()
    debouncedMethod()

    time.Sleep(5 * time.Millisecond)

    if executionCount != 1 {
        t.Errorf(&quot;The method was not called only once, called %v time(s)&quot;, executionCount)
    }
}
</code></pre>

<p>The good news is&hellip; our implementation already validates this rule ! No refactoring seems to be needed, we are just making our API more robust with the previous test and the following.</p>

<p>We also need to check that the method is executed multiple times if enough time was spent between the calls.</p>

<p>We just need to tweak the previous test a little :</p>

<pre><code class="language-go">func TestShouldBeAbleToCallTheFunctionAgainAfterTheTimer(t *testing.T) {
    executionCount := 0
    debouncedMethod := Debounce(func() {
        executionCount++
    }, 5)

    debouncedMethod()

    time.Sleep(10 * time.Millisecond)

    debouncedMethod()

    time.Sleep(10 * time.Millisecond)

    if executionCount != 2 {
        t.Errorf(&quot;The method was not called twice, called %v time(s)&quot;, executionCount)
    }
}
</code></pre>

<h2>Conclusion</h2>

<p>I cannot think of any other use case for this basic debouncer, and the API feels fine to me.</p>

<p>The complete implementation looks like this :</p>

<pre><code class="language-go">func Debounce(function func(), executeAfter int) func() {
    duration := time.Duration(executeAfter) * time.Millisecond
    t := time.NewTimer(duration)
    t.Stop()

    go (func() {
        for {
            select {
            case &lt;-t.C:
                log.Println(&quot;Executing the debounced method&quot;)
                go function()
            }
        }
    })()

    return func() {
        log.Println(&quot;Reset the debouncer timer&quot;)
        t.Reset(duration)
    }
}
</code></pre>

<p>This may not be the best debouncer out there, nor that it is the best scenario of a <em>test driven development</em>.</p>

<p>Yet I think it illustrates how natural it is to write tests and little helpers in Go.</p>

<p>I started writing the debouncer with no tests, leading to a wanky unpredictable API, that I had to test manually with a real world example to validate.</p>

<p>Starting over and driving the develoment by the tests helped me writing a way simpler helper that I could rely on !</p>
</main>
    <footer>Â© Thomas Ferro - 2021</footer>
</body>
</html>